■ TDA 관련
Threads : 전체 스레드 목록
Threads sleeping on Monitors : 대기중인(sleeping) 스레드 목록
Threads locking Monitors : 잠겨 있는 스레드 목록
Monitors : 잠겨있는 스레드 목록, 모든 락의 원인이 되는 스레드를 식별하기 쉽게 해준다.

ps -Lf -p 프로세스아이디를 입력한다

UID	PID	PPID	LWP	C	NLWP	STIME	TTY	TIME		CMD
사용자ID	프로세스	부모프	스레드ID	CPU사용량	LWP개수	프로세시작	통제터미널	CPU점유시간	프로세스 수행시킨 명령어

CPU 사용량이 많은 스레드 ID를 구해서 TDA에서 해당 스레드 ID와 관련지어 분석

■ TDA 보는 순서
1. 전체 스레드 개수 확인
2. JDK 6이상을 쓸 경우 스레드 단면에 있는 Root 노드를 클릭하여 메모리 사용량을 확인해보고 단면 파일 여러 개를 비교해 가면서
   값이 어떻게 변하는지 살펴본다.
3. Monitor 목록에서 빨간색으로 표시되어 여러 스레드들을 잡아먹는 것이 있는 확인해본다.
4. 1에 해당하는 스레드가 보이지 않을때는 Runnable인 스레드들을 확인해본다.
5. 지속적으로 수행중인 스레드가 존재하지 않은지 Long running threads detect기능을 사용하여 확인한다.
6. 그래도 이상이 없어 보인다면 다른 원인을 찾아본다.

■ 시스템이 응답이 없을때
1. 스레드 단면을 주기적으로 생성해 놓는다.
2. 스레드 단면을 뜰 때 ps -Lf -p pid 명령어도 같이 수행하여 주기적으로 생성해놓는다.
3. 2단계에서 점검한 스레드 중 CPU사용 시간이 지속적으로 증가는 게 있다면 해당 스레드 ID를 확인한 후 TDA를 열어 방금 생성한
   단면에서 해당 스레드가 어떤 것인지 확인해본다.
4. 3단계에서 확인한것이 GC 관련 스레드라면 메모리가 부족하거나 GC알고리즘에 문제가 발생했을 확률이 높다. 따라서 jstat명령어로
   메모리 사용량을 확인한 후 메모리가 부족하면 메모리 단면을 생성해 어떤 객체가 메모리를 가장 많이 잡아먹는지 확인한다.
5. 3단계에서 확인한게 GC 관련 스레드가 아니라면 해당 스레드가 지속적으로 수행되는지(무한루프) 확인한다.

■ 스레드 상태
new : 스레드가 생성되었지만 아직 실행되지 않은 상태
runnable : 현재 cpu를 점유하고 작업을 수행중인 상태, 운영체제의 자원분배로 인해 waiting상태가 될수도 있다.
blocked : monitor를 획득하기 위해 다른 스레드가 락을 해제하기를 기다리는 상태
waiting : wait(), join(), park()메서드 등을 이용해 대기하고 있는 상태
timed_waiting : sleep(), wait(), join(), park()메서드등을 이용해 대기하고 있는 상태
                waiting상태와의 차이점은 메서드의 인수로 최대 대기 시간을 명시할 수 있어 외부적인 변화뿐만
                아니라, 시간에 의해서도 waiting 상태가 해제될 수 있다는 차이점이 있다. 

■ 스레드 덤프 유형별 패턴
락을 획득하지 못하는 경우 (blocked)
→ 한 스레드가 락을 소유하고 있어 다른 스레드가 락을 획득하지 못해 앱의 전체적인 성능이 느려지는 경우

데드락 상태인 경우

원격 서버로부터 메시지 수신을 받기 위해 계속 대기하는 경우
→ runnable 상태에 있어 문제가 될 만한 부분이 없는 것처럼 보일수도 있지만 스레드 덤프를 시간순으로
  나열하면, socketReadThread 스레드가 계속 소켓을 읽으려 무한정으로 대기하고 있는 상태에 있을수
  있는 상황도 있다.

wait상태에 있는 경우

스레드 리소스를 정상적으로 정리하지 못하는 경우

■ 예시
ps -mo pid,lwp,stime,time,cpu -C java 를 통해 LWP 고유번호를 구한다.
이를 16진수로 변환하여 NID를 얻는다. (10039 → 0x2737)

스레드덤프로 해당 NID를 가지는 스레드를 찾아 동작을 확인한다.

앱의 수행 성능이 비정상적으로 느릴 때에는 blocked 상태인 스레드가 원인인 경우가 많다.
이때에는 스레드 덤프를 여러번 얻은 다음 blocked 상태인 스레드가 획득하려는 락과 관계된
스레드를 추출해본다. 해당 락을 획득하고 있는 스레드의 스택트레이스를 분석하면 문제를 해결
할수 있다.

  
