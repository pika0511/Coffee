■ 스레드 덤프가 필요한 상황
 - 모든 시스템에 응답이 없을때(시스템 행 걸린 상황)
 - 사용자 수가 많지도 않은데 시스템 cpu 사용량이 떨어지지 않을때
 - 특정 애플리케이션을 수행했는데 응답이 없을때

■ 스레드 덤프 수행방법
 - kill -3 <pid>		: 시스템 로그가 생성되는 위치에 해당 파일이 생성된다.
 - jstack <pid> > filename	: 콘솔에 직접 출력되며, 해당 파일이름으로 저장
 ※ kill 명령어를 가급적이면 권장(jstack 명령어는 출력시간이 kill에 비해 더 걸리고, 시스템에 영향이 큼)
 ※ 스레드 덤프 수행시 ps -Lf -p <pid>도 주기적으로 실행하여 저장(스레드별 cpu 사용시간 정보등)
 ※ ps -Lf -p <pid> 항목
  ㄱ. PPID : 부모 pid
  ㄴ. LWP : 스레드 id
  ㄷ. NLWP : 해당 프로세스에서 사용하는 스레드 수
  ㄹ. C : 해당 프로세스가 지속적으로 사용하는 cpu 사용량 
 ※ 스레드 덤프 수행시 5초 간격으로 5~10회 수행
 
 ※ 기존 수행 방법 첨부(파일명을 시스템 시간정보가 반영되어 출력되도록 수정할 것)
149 서버
jstack 13217 > /home/mcslog/jstack1.txt
jstack 13217 > /home/mcslog/jstack2.txt
jstack 13217 > /home/mcslog/jstack3.txt
jstack 13217 > /home/mcslog/jstack4.txt
jstack 13217 > /home/mcslog/jstack5.txt

150 서버
jstack 21236 > /home/mcslog/jstack1.txt
jstack 21236 > /home/mcslog/jstack2.txt
jstack 21236 > /home/mcslog/jstack3.txt
jstack 21236 > /home/mcslog/jstack4.txt
jstack 21236 > /home/mcslog/jstack5.txt


■ 스레드 덤프 파일 분석
 - TDA 설치
 - Threads : 전체 스레드 목록
 - Threads Sleeping on Monitors : 대기중인 스레드 목록
 - Threads Locking Monitors : 잠겨있는 스레드 목록
 - Monitors : 모든 락의 원인이 되는 스레드를 식별하기 쉽게 출력
 - Monitor 클릭 : 락으로 대기중인 스레드가 많은 항목에 대해 빨간색으로 표시됨

■ 스레드 관련된 문제상황
 - GC 관련 스레드가 대부분의 cpu를 점유할때 시스템이 느려짐
 - 전체적인 시스템이 항상 느릴때/특정 기능(화면)이 느릴때/특정 시간대(기간)에 전체 애플리케이션이 느릴때
   특정 시간대(기간)에 특정 애플리케이션이 느릴때/특정 기능(화면)이 점점 느려질 경우/특정 사용자에게만 애플리케이션이 느릴 경우
   → 리소스 점검(cpu, 메모리), 외부 리소스 점검, 스레드 및 메모리 상태 점검

 - 시스템 응답이 없을때
   ㄱ. 전체 스레드 개수 확인
   ㄴ. Monitor 목록에서 빨간색으로 표시되어 여러 스레드를 잡아 먹는 것이 있는지 확인
   ㄷ. Runnable 스레드 확인
   ㄹ. Long running threads detect 기능을 통해 지속적으로 수행중인 스레드 확인
   ㅁ. Root 노드를 클릭하여 메모리 사용량 확인

 - cpu 사용량이 급증할 때
   ㄱ. 메모리가 부족하여 GC관련 스레드만 반복 수행
   ㄴ. Regular Expression을 잘못 사용하여 무한루프가 수행될 때
   ㄷ. XML Parser에서 특수문자에 의해 무한루프가 수행될 때
   ㄹ. 애플리케이션상에서 무한루프 로직이 수행될 때
 
■ 스레드 관련 블로그
http://d2.naver.com/helloworld/10963

=================================================================================================

■ 힙 덤프가 필요한 상황
 - 메모리 누수가 의심될때(Full GC후에도 메모리 사용량이 80~90% 이상일때)

■ 힙 덤프시 주의사항
 - 덤프생성시 서비스가 불가
 - 생성소요시간이 길다.
 - 메모리 크기만큼의 파일이 생성

■ 힙 덤프 수행방법
 - jvm heap 상태 확인 
	jmap -heap <pid>
 - 클래스별 객체 수와 메모리 사용량 확인  
	jmap -histo:live <pid> | more
 - 실시간 heap 메로리 사용 정보 확인 
	jmap -heap:format=b <pid>
 - heapdump 파일 생성(filename : *.hprof 형태) 
	jmap -dump:format=b, file=<filename> <pid>
 - jvm의 pid 확인
	jps -v

 - 메인 메소드명 포함
	jps -m

 - 전체 패키지명 포함
	jps -i 

 - heapdump 분석 (jhat)
	jhat heapdump경로
	http://localhost:7000 로컬 웹서버가 구동된다. 접속해서 heapdump 분석 결과 확인 가능

 - Eclipse의 MAT 설치후 heapdump 파일 로드
	Getting started Wizard에서 Leak Suspects Report 선택	
	분석결과 상단에 Open Dominator Tree for entire heap
	메모리를 많이 차지하고 있는 객체 위주로 노출되므로, Retained Heap 항목을 선택하여 개선


■ 힙 덤프 분석
 - 이클립스상에서 MAT 설치
 - Leak Suspect Report 선택
 - Details 클릭
 - Description :해당 객체에 대한 설명
 - Shortest Paths To the Accumulation Point
   Accumulated Objects
   메모리를 점유하고 있는 객체를 각각 내림차순 / 오름차순 출력
 - Accumulated Objects by Class
   클래스별로 객체를 점유하는 대상목록
 - 각각의 객체를 클릭하여 상세정보 확인 가능
   List Objects : incoming / outgoing 참조 객체를 보여줌
   Paths to GC Roots : GC Root들을 보여줌
■ 시스템이 느린 것과 메모리의 관계
 - 메모리 크기를 잡지 않거나 너무 작게 잡아 GC가 자주 발생하는 경우
 - 임시 메모리를 많이 사용하여 GC가 자주 발생하는 경우

■ 응답이 없는 것과 메모리 관계
 - 메모리가 부족하여 GC가 자주 발생할 경우
 - Full GC후 메모리 사용량이 20~50%이면 정상, 80~90% 이상이면 메모리 누수
  
===============================================================================================

■ Java VisualVM 설치
 - http://visualvm.java.net
   별도 다운로드 버전으로 다운로드 하는 것을 권장

■ vmstat
 - vmstat -옵션 delay count
 - Procs	R : 실행하기 위해 대기하고 있는 프로세스 수
		B : 중단 불가능한 슬립상태에 있는 프로세스 수
 - Memory	Swpd : 가상 메모리를 사용한 크기
		Free : 사용하지 않는 메모리 크기
		Buff : 버퍼로 사용하는 메모리 크기
		Cache : 캐시로 사용하는 메모리 크기
 - Swap		Si : 초당 디스크에서 읽은 스왑된 메모리 크기
		So : 초당 디스크로 스왑된 메모리 크기
 - IO		Bi : 블록디바이스에서 받은 블록수
		Bo : 블록디바이스로 보낸 블록수
 - System	in : 클럭을 포함한 초당 인터럽트 수
		Cs : 초당 컨텍스트 전환 개수
 - CPU		Us : 사용자 코드를 수행하는데 소요된 시간
		Sy : 커널 코드를 수행하는데 소요된 시간
		Id : Idle상태에서 수행하는데 소요된 시간(I/O 대기시간 포함)
		Wa : I/O 대기 소요시간
		St : 가상머신에서 뺏긴 시간
 
 - 옵션 		k : 1000단위로 출력
		K : 1024단위로 출력
		m : 1000000단위로 출력
		M : 1048576단위로 출력

■ 프로세스 관련 명령어
===프로세스===

ps -ef | grep 프로세스이름
프로세스 상태를 확인하는 명령(ps -C 프로세스이름과 동일)

pidstat -p <pid1>, <pid2>, <pid3>, ,,,
프로세스별 cpu 사용량 모니터링 

pmap <pid>
프로세스의 메모리 구성

kill -9 프로세스번호
프로세스 강제종료

===프로세스===

■ netstat 관련
netstat -a | grep ftp
netstat -a | grep sshd

netstat -lt
리스닝 상태인 프로세스



==========================================================================================================
    문제점 진단
==========================================================================================================



■ 시스템 느림 현상이 발생 경우

 1. 전체 시스템이 항상 느린경우
 2. 특정 기능(화면)이 느린경우
 3. 특정 시간대(기간)에 전체 애플리케이션이 느린경우
 4. 특정 시간대(기간)에 특정 애플리케이션이 느린경우
 5. 특정 기능(화면)이 점점 느려질 경우

위와같은 장애가 발생할경우 2~3분정도 근거 자료들을 남겨놓고 JVM을 다시시작



=== 전체 시스템이 항상 느린경우 ===

 ㄱ. 프로세스 CPU점유상황 체크 
 ㄴ. CPU사용량 체크 
 ㄷ. 네트워크 사용량 체크  
 ㄹ. 메모리, I/O 등 기타 리소스 사용량 체크 
 ㅁ. DB연결 설정 체크 
 ㅂ. WAS 쓰레드, 메모리 등 설정 체크 
 ㅅ. WEB 서버 설정 체크 
 ㅇ. OS 설정 체크 
 ㅈ. JVM 쓰레드 상태 체크 
 ㅊ. JVM 메모리 사용량 체크 
 ㅋ. ACCESS log 확인 
 ㅌ. WAS의 각종 로그 확인


=== 특정 기능(화면)이 느린경우 ===

 ㄱ. 느린 화면만 수행할 수 있는 별도의 환경 준비
     - 가장 좋은 것은 해당 서버를 운영 그룹에서 제거하는 방법 

 ㄴ. CPU 사용량을 체크하면서 해당 애플리케이션을 수행
    - 만약 CPU 사용량이 높다면 해당 애플리케이션 수정 
    - 만약 CPU 사용량이 낮다면, 해당 애플리케이션과 연계되는 시스템 확인
    - 대부분 이러한 경우 DB 쿼리가 느릴 확률 90% 

 ㄷ. 쓰레드 상태를 체크 (5회 이상)
    - 애플리케이션이 어떤 작업을 하고 있는지 확인 

 ㄹ. 메모리 사용량 체크
    - 서버의 메모리 사용량을 확인하면서 애플리케이션을 수행하여 메모리 증가량 확인 


=== 특정 시간대(기간)에 전체 애플리케이션이 느릴경우 ===

 ㄱ. Access log 분석을 통해서 어떤 애플리케이션이 수행되었는지 확인
  
 ㄴ. 애플리케이션 목록이 평소와 별로 다를 것이 없다면, 서버의 튜닝이 제대로 되어있지 않은 것이므로,
     '전체 화면이 느린 경우' 에서 체크하는 모든 단계를 거칠것.

 ㄷ. 애플리케이션 목록이 평소와 다르다면, 그 시간대에만 많이 호출되는 애플리케이션에 대해서 진단
     방법 1. 문제의 정확한 원인을 찾기 어려울 경우
         - 부하 상황에서 모니터링 
         - 병목지점 파악
         - 튜닝 실시 
     방법 2. 애플리케이션 문제일 경우
         - 애플리케이션 프로파일링
         - 병목지점 파악
         - 튜닝 실시 


=== 특정 시간대(기간)에 특정 애플리케이션이 느린 경우 ===

 ㄱ. 애플리케이션 프로파일링 실시
     - 병목지점 파악 

 ㄴ. 특정 애플리케이션의 호출 관계 확인
     - 연계 시스템 상황 확인 


=== 특정 기능(화면)이 점점 느려질 경우 ===

 ㄱ. 해당 애플리케이션에서 사용하는 DB 점검
   - 쿼리 플랜 확인 | DB Lock 상황 확인 | 테이블 데이터 개수 확인 | DB 병목일 확률 90% 이상 

 ㄴ. WAS쓰레드 단면을 떠서 Lock이 발생하지 않았는지 확인
 
 ㄷ. 접근하는 파일이나 로그의 크기가 너무 크지 않은지 확인





■ 응답이 없을 때는 이렇게 

 - WAS 장비에 있는 CPU를 하나이상 100% 점유하면서 시스템이 응답하지 않는 경우
 - WAS 장비에 있는 CPU 사용량은 10% 미만이지만 시스템이 응답하지 않는 경우


=== WAS 장비에 있는 CPU를 하나이상 100% 점유하면서 시스템이 응답하지 않는 경우 ===

 ㄱ. 시스템 로그확인
 ㄴ. WAS Thread 상태 점검
 ㄷ. 메모리 사용량 및 GC 상황 점검


=== WAS 장비에 있는 CPU 사용량은 10% 미만이지만 시스템이 응답하지 않는 경우 ===

 ㄱ. Web 서버 점검
     - CPU 사용량 점검
     - 프로세스 상태 점검
     - 각종 로그를 쌓는 디렉터리의 용량 및 로그 파일 크기 확인 )

 ㄴ. Was 점검
     - CPU 사용량 점검
     - 각종 로그를 쌓는 디렉터리의 용량 및 로그 파일 크기 확인
     - Web 서버와의 연결 상태 점검 
     - WAS Thread 상태 점검
     - 메모리 사용량 및 GC 상황 점검
     - DB Connection Pool 사용량 점검 

 ㄷ. DB 점검
     - DB CPU 사용량 점검
     - Connection 상태 점검
     Lock 상태 점검 )

 ㄹ. 외부 연계 모듈 상황 점검

 ㅁ. '전체적인 화면이 느린경우' 에서 점검하는 모든 항목 점검 



==========================================================================================================
    TOP ( 실시간 시스템 모니터링 명령어 )
==========================================================================================================


■ top 화면 상단 제공 항목
 - 1행 
    날짜정보( 현재 시스템 시간) 
    user ( 터미널을 통하여 시스템에 접근한 사용자 세션 갯수 )
    load average ( 부하 평균, 좌측부터 1분, 5분, 15분간 평균값 )
 - 2행 : 수행중인 작업에 대한 통계
    Tasks : 수행중인 전체 프로세스 수
 - 3행 : CPU 사용량을 제공
 - 4행 : MEMORY 사용량을 제공 
 - 5행 : 스왑 메모리 영역 정보를 제공한다.
       

■ top 화면 하단 제공 항목
 - PID  : 프로세스 아이디
 - USER : 사용자 아이디(해당 프로세스를 수행한 사용자 아이디를 말한다.
 - PR   : 우선 작업 순위
 - NI   : 작업의 nice값, 값이 음수일 경우 매우 높은 우선순위를 뜻한다.
 - VIRT : 작업에서 사용한 가상 이미지를 사용한 크기(kb단위)
 - RES  : 점유한 메모리 크기. 다른 프로세스와 공유할 수 있는 메모리 크기
 - SHR  : 공유 메모리 크기, 다른 프로세스와 공유할 수 있는 메모리 크기
 - S    : 프로세스 상태, 5가지로 나누어 진다.
          D : 중단 불가능한 잠자기 상태 ( uninterruptible sleep )
          R : 실행중인 상태
          S : 잠자기 상태
          T : 트레이스 되었거나 중지된 상태
          Z : 좀비상태
 - %CPU : CPU 사용량
 - %MEM : 메모리 사용량
 - TIME+: 프로세스가 CPU를 점유한 누적된 시간값을 제공한다
 - COMMAND : 명령어 정보

■ top 단축키
 - 1 : 상단 통계창에 CPU별 정보를 출력한다.
 - O 혹은 F : 보여주는 데이터를 원하는 항목 기준으로 정렬한다.
 - G : 이미 지정되어 있는 항목 그룹을 사용할 수 있다. 최대 4개까지 사용 가능하다.
 - R : 정렬기준을 오름차순으로 할지 내림차순으로 할지 변경한다.
 - X : 현재 정렬 기준 항목의 열을 하이라이트 해 준다.
 - H : 쓰레드 정보를 보여줄지 여부를 결정한다. 기본은 프로세스 정보만 제공한다. 
       특정 쓰레드가 CPU 를 점유할 경우, 점유중인 쓰레드 id를 확인할 때 유용하게 사용된다.
 - space 혹은 Enter : refresh
 - I : 현재 수행되고 있지 않은(idle인) 프로세스 정보를 제공할지 여부를 변경한다.
 - Y : 상단 작업 목록 화면에서 실행중(running)인 상태로 나타나는 프로세스를 하이라이트 해서 볼 수 있다.
 - U : 특정 사용자 계정이 수행한 프로세스들만 출력한다. 
       모든 프로세스를 출력하려면 u를 입력하고 엔터키만 치면된다
 - n 혹은 # : 목록에 출력되는 프로세스 개수를 지정한다.
 - C : 전체 명령어 경로를 화면이 허락하는 데까지 출력한다. 
       해당 프로세스에서 커맨드 옵션을 보려면 이 단축키를 사용하면된다.
 - K : k를 누르고 입력한 pid를 갖는 프로세스를 죽인다.
 - R : 프로세스에서 nice값을 다시 지정할 수 있다. 프로세스 아이디를 입력하고 nice값을 지정하면 된다.
 - S : 이미 종료된 자식 프로세스에서 CPU를 사용한 시간까지 출력한다.
 - d 혹은 s : 데이터 갱신주기를 변경한다. 기본은 3초,
 - W : 현재 사용중인 설정을 저장한다. 보고있는 정렬 옵션, 
       화면 구성등을 저장해 놓고 다음부터 동일하게 사용하고 싶은 경우에만 입력해야한다.
 - Q : 나가기

■ 화면 구성 변경 단축키
 - Z : 화면에 보여주는 데이터 색에 대한 구성을 지정하는 화면으로 이동.
 - B : 강조되는 내용을 굵은 글씨로 보여준다.
 - F : 화면에 출력되는 항목을 지정한다. 출력하기를 원하는 항목에서 가장 앞에 있는 알파벳을 입력하면된다.
 - O : 화면에 출력되는 항목 순서를 지정한다.
 - Z : 컬러모드인지 흑백 모드로 보여줄지 지정한다.
 - B : x나 y로 강조되어 있는 상황에서 해당 항목을 반전된 글씨로 보여줄지 지정한다. 


■ 시작옵션

※기본옵션
 -b : 배치모드로 수행한다.
 -c : 커맨드 전체 경로와 옵션을 출력한다.
 -H : 쓰레드를 출력한다.
 -i : idle한 프로세스를 제외하고 출력한다.
 -s : Secure mode로 수행한다.
 -S : 누적시간 모드로 출력한다.

※추가옵션 ( 기본옵션과는 별도로 수행 )
 -d : 초 단위로 반복 주기를 지정한다.
 -n : 반복 횟수를 지정한다.
 -u : 지정한 사용자 계정에서 수행한 프로세스만 출력한다.
 -p : pid를 지정한다. 콤마(,)를 사용하여 여러 pid를 지정할 수도 있다.

 ex) $ top -cHi -d 10 -n 3
