1. 인덱스 생성/삭제 작업의 세부 절차(스레드 관점/메모리 할당 및 해제 관점)
생성작업 시작 : 과거 데이터가 있는 경우에(옵션 킨 경우) 태스크가 백그라운드로 돌고 ,나머지는 실시간으로 인덱싱
당일치 데이터는 입력을 블록을 하고 만든다. 그래서 생성 직후에 삭제가 안되는 이슈가 있다.(해결 예정)
인덱스 작업은 하루치 단위로 반복을 하는데 당시에 하루치 데이터를 여러블럭으로 나눠서 작업하는데, 단위 작업마다 메모리를 정리해야 하는데, 정리 안하던 오류가 있었다.
메모리 해제 작업 단위가 하루치 작업 단위여서 만약 여러개의 인덱싱 스레드가 돌면서 하루치 작업을 동시에 하면 OOM 발생 가능
하루치 작업은 보통 2-3시간 단위(이번 케이스에 국한됨)
(1일 데이터 수집량에 따라 1일치 인덱스 빌드 작업시 소요되는 메모리 상황이 다르다.)

인덱스 삭제 시 백그라운드 스레드 중지가 되지 않고 있어서 
인덱스 생성/삭제를 여러번 수행할 경우 메모리 증가 추세가 가속됨

하루치 데이터가 많기 때문에 하루치 작업에 2~3시간 이상 소요될 것으로 예상
인덱스 생성을 한번만 했었다면, 3시간 후에 메모리 사용량이 떨어지면서 문제가 안되었을 것.(기존 : 메모리 정리 단위 하루치 작업이 끝나면)
(개선 후 : 단위 작업별 메모리 정리) 지정된 메모리 사용량을 넘지 않을 가능성도 있음
예를 들어 하루치 작업동안 (일시적으로) 누수되는 양이 10G라고 하고 힙 최대치 설정이 16G 라고 하면
인덱스 하나만 생성했으면 문제가 안 생겼을 것.
그런데 3개를 동시에 생성하면 문제가 발생함.

4. 누수의 원인이 된 객체(역할/GC대상에서 제외된 원인(메모리 참조가 유지된 원인))
메모리에서 인덱스를 검색하기 위한 최소 자료 단위 (onlineIndex) - 추가 질문 필요시 직접 문의 필요

5. 인덱스 생성시 토큰 미설정 방법
(현재 생성된 인덱스 생성 방법의 문제점)


6. 절체 상황의 세부 절차
절체 기준 : 1초에 한번씩 반대노드에 포트가 열려있는지 확인, 연결 실패가 1분이상(node threshold) 반복되면 절체
*node failure threshold  1분 으로 설정 (1분 이하의 GC를 견디기 위한 조치)
8888포트를 두노드가 확인중
gc가 심하게 일어나면 8888포트가 닫히는게 아니라 응답이 늦어 진다.  /서버가 죽으면 8888포트가 닫힌다.
컨넥션 실패 없이 응답이 늦을 경우는 gc때문이라,  *node failure threshold를 보통 1분으로 설정

7. 하나의 수집기는 하나의 스레드 전제는 지금은 유효
기존에는 stop 신호 유실 이슈가 있어(유실 원인은 start/stop 변환 속도가 빨라서? OK), 하나의 수집기에 대해 스레드가 증가되는 이슈가 있었음
수집기 스레드는 gui/cli의 start/stop 신호에 따라 생성 및 삭제되도록 설계
절체될때 또한 수집기 스레드에 stop 신호로 반전되는지? 
while (!stop) {
}
-> 언젠가 계속 반전되면서 해당 스레드가 사라지겠지만, 동시에 하나의 수집기에 대해 2-3개 이상의 스레드가 존재할 경우가 발생할 수 있음
-> 문제는 하나의 jsch 객체에 대해 이렇게 둘이상의 스레드가 존재할 경우, jsch에서 스레드가 누수되는 경우가 발생할 수 있음
-> 이로 인해 sshd 급증
-> jsch 스레드가 누수되는 절차(하나의 수집기에 대해 둘이상의 스레드가 존재하는 경우와 관련지어)
수집기 스레드가 2개 이상이 jsch에 액세스 못하도록 개선 조치 취함

jsch
1초에 한번 커넥트-클로즈를 반복하는데 2개이상의 스레드가 jsch객체에 동기화없이 접근하면 커넥션 누수가 발생
(jsch객체 내부에서 내부변수가 스레드 세이프 하지 않다. 클로즈시에 클로즈 작업 도중에 커넥션이 호출 되는 경우 내부상태가 꼬일수 있음) 
클로즈 없이 커넥트를 호출하는 경우가 발생하여 sshd thread가 급증의 원인이 되었을 것

*sshd가 급증하는 그래프의 형태를 보인 것과 연관해서
ssh 접속 하나당 서버스레드가 2~3개가 생성된다.(증명 :성능모니터링 당시 로그프로세스 자바 스레드 숫자 : 3000 여수준, 서버 스레드수 : 7000여수준 을 보면 증명됨)(실제보다 2배정도 뻥튀기 되었다.)
실제는 커넥션(로그프레소서버) 하나당 

그래서 3000으로 봐야하고
3000이라는 숫자는 /60 하면 500
초당 스레드 증가 속도
초반 10분간 600개 로그프레소 스레드 증가 -> 서버 스레드는 1200까지 증가
이후 속도가 빨라진 것은 로그프레소 절체가 이후 추가 진행되면서 수집기 스레드가 갯수가 1~2개 더 증가했고 커넥션 누수 속도도 이에 맞춰 더 증가함


while (!stop && thread.startTimestamp == logger.startTimestamp) {
※ logger.startTimestamp는 계속해서 증가하므로, while fail 조건이 성립 -> thread 동작 중단
※ 수집기의 스레드수가 1개 이하로만 관리되도록 개선됨
}
개선 후 - start에 timestamp를 적용해서 중지 가능케함

8. 절체 시작전 절체의 판단 로직
위에
9. 절체 개시 후 절차(절체시 개별 수집기 변경 동작 단계적 세부적 서술)
변경 동작 항목 : 수집기 stop/start  ///  테이블 락 ...
수집기 관련 : active-standby 수집기간의 테이블 쓰기 lock 상호 반전, 기존 노드의 수집기에 stop 반전처리
절체시 기존 노드가 행이 걸릴때 나타나는 문제점(신규 active서버가 신규 standby서버와 상호작용이 없는지)
테이블 락과 수집기가 영향을 받는다. (테이블 락은 반전되고, 수집기는 start/stop 변경)
active노드도 standby 노드에 대해 포트가 열려있는지 게속 확인함
테이블 실시간 동기화의 목적도 있음

9. 테이블 쓰기 lock이 걸려 있는 경우 수집이 되어 있을때는 반대 노드로 데이터를 보내주는 형태로 동작.
반대 노드에 데이터를 보내주고 체크 여부?
계속 수집이 이루어질 경우 반대 노드로 게속 데이터를 보내준다?


절체시 standby수집기에서 쓰기락 해제없이 수집진행되어

10. 절체가 1초 미만으로 일어나는 경우 수집이 중복으로 일어난다는 것의 의미는 상호배타적으로 동작하지 않는 것이 아닌지?(수집기쌍이 동시에 작동하고 있을때가 전혀 없는지)
동시에 동작할 경우 스탠바이 수집기에서 수집내용을 버린다. (동시 동작 극히 드물다.)
11. (동시에 작동하고 있다면 그 과정에서의 데이터 처리는 어떻게 되는것인지)

active노드 수집기 스레드가 수집중일때, 절체되지 않은 상태에서 hang (스탠바이에서는 수집기가 쓰기락으로 대기)
그러면 60초 보고 있다가 스탠바이가 올라온다.

stop/start 작업 누적의 이유?
-메인 : 빠른시간안에 절체 반복 (락/락해제 반복) -> 지체되는 작업이 발생할수 밖에 없고, stop/start 작업 누적

00정상적인 경우에 두 노드가 살아 있는 경우, active/standby 테이블을 동기화를 하는데 동기화 하기전에 로컬에 있는 테이블을 닫는다.
테이블을 닫는 과정에 hang 이 걸림(테이블이 안 닫혔다.)
테이블 동기화시 테이블을 닫는다.

00절체가 되서 스탠바이 수집기에 stop이 걸리는 경우 인터럽트를 거는데, 인터럽트 타이밍이 잘못되면 인덱스 클로즈가 제대로 안되는 현상이 있을 수 있다.
인덱스가 자기의 태스크가 미완성인 경우 완성을 기다리게 되어 있는데, 거기서 행이 걸린다. (수집기에 수집된 것을 인덱스로 준다. 서로 연관있다.)
거기서 행이 걸리면 stop/start 명령이 줄을 서게 되고 stop/start가 동시에 처리되는 경우가 발생하여 수집기 스레드가 2개가 될수 있게 된다.

 
스탠바이의 쓰기 lock(active 수집기가 동작중일때 스탠바이 테이블에 쓰기 lock)(standby노드가 수집기가 정지중일때도 쓰기lock은 걸려 있는 상태) 으로 인해 
(절체가 반복되면서 stop/start 작업 누적-바로 처리않은 이유 : 이후에 다시)stop/start 작업이 같이 hang 되어 있다가 active 가 일시적으로 살아났을 때 
우연히 거의 동시에 수행되면서(stop↔start 값 할당 작업) stop 신호가(start<->stop 빠르게 전환) 유실됨
stop 신호가 유실되면서 기존 수집 스레드가 사라지지 않고, 신규 수집 스레드가 생성

절체가 반복될때 (stop↔start 값 할당 작업 반복)

12. 절체시 기존 active서버에서의 sftp 커넥션 클로즈 여부
jsch의 동작 절차


--13. 절체시 기존 active서버에서의 sftp 수집기가 종료(기존 sshd 커넥션 클로즈)한 이후 standby 수집기가 작업 개시했는지 / 종료되지 않은 상태에서 작업시작 했는지
--14. 절체시 standby서버에서 sftp 수집기 스레드 상황 및 sftp 접속 시도 상황
--15. (수집기 관련 스레드는 수집기 개수로 고정되어 있는 것이 맞는지 확인)
--16. 수집대상서버의 sshd가 급증한 것은 active서버의 sftp수집기 컨넥션을 맺은채로 행이 걸려(즉 미종료)
--------------------액티브는 행이걸려 아무일도 못하고 있어서 언급 필요가 없다.

스탠바이가 원인이었음 : standby서버에서 커넥션을 지속요청하여 sshd가 급증

17. 액티브노드 수집기는 항상 수집을 할려고 하고 테이블 락이 없어 테이블에 적재하는 것이 기본동작이며 스탠바이노드 수집기는 stop신호로 정지해있는 것이 기본이지만 start되어 스레드가 생겨날 경우
테이블 락이 걸려 있어 항상 제한적이다.

*18. 동일한 수집대상에 대해 수집기 다수의 스레드가 동시에 엑세스해서 읽을려고 할 경우, 동시에 읽는지/시리얼하게 읽는지
수집기 스레드가 동시에 읽을 것으로 기대하는데 hp ux의 동작에 달려 있다.

19. 수집시 수집대상 파일에 쓰기작업이 수행중일때 수집은 대기하는지 바로 읽는지(읽기 락이 걸려있는지)
쓰고 있어도 읽는다.

20. 수집 속도가 저하되어 로그생성속도가 수집속도보다 빨라질때, 미수집 로그 누적량이 존재한채로 로그 파일이 교체될때는 해당 미수집 로그는 수집 불가한건지
수집속도가 오히려 빠르면 미수집 로그가 발생할경우가 미미하지만 존재한다.(하단 파일 교체 사례 28.)
수집속도가 저하되는 경우에는 문제가 없다.

21. 한줄 읽기 검사후 멀티라인을 수집해올때의 한번 수집량의 기준은? 서버가 주는 만큼 받는다.
원래 동작하던 것은 서버에서 읽을 량이 남아 있다면 1초 지정된 시간보다 더 길게 작업한다.
폴링 시점은 1초 간격으로 지정되어 있고
1초내에 0.3초 작업했다면 0.7초 쉰다.
1초가 넘어서 1.3초 작업했다면, 기존 폴링시점을 놓쳐다고 해서 0.7초를 쉬는게 아니라 이때는 바로 작업 다시 시작
싱글스레드인데 최대 휴식시간이 1초이다.
받는 쪽 부하를 신경쓰지 않고 수집속도 최대화를 하는 것으로 설계 됨


22. GUI상에서 cache 설정 - 테이블, 역인덱스, 블룸필터lv0, 블룸필터lv1(메모리 설정의 비율 근거), 각 비율에 대한 효과
cep, 인덱스 생성, 등의 기타작업에 할당할 다이렉트 메모리가 없어져 OOM 발생가능
80~90%를 권장

23. ftpaccess 설정 내용 변경 후 임종오선임 메일링
allow-retrieve 없이 해보고 안되면 그 이상은 

*24. | search 필드명=="값" (컬럼 기준 검색시는 columnar유리?), fulltext?(row-oriented data block, column-oriented data block)
모든 테이블 생성시에 columnar 방식으로?/row 기준 테이블 생성이 유리한 경우는?(로그프레소 상에서)
컬럼수가 적으면 row 가 유리
columnar는 인덱스 활용도가 낮다. 인덱스 안쓴 경우가 오히려 더 빠른 경우가 많다.
fulltext를 위주로 쓸거면 row타입으로 한다.
원본을 그대로 저장하는 경우는 무조건 row타입으로 저장

25. 테이블 생성시 데이터배열 선택없이 생성하면 테이블 정보 조회에서 표시가 안되는데, 이것은 디폴트로 row- 반영이 된것인지?
디폴트가 row 타입임

26. sys table 정보들은 어떤식으로 적재가 되는지(syslog 포트를 통해 수신하는지, 직접 파일을 통해 수집하는지)
내부적으로 관련 수집 스레드가 게속적으로 작동

27. 시스템 설정-포트설정-syslog포트(UDP) 514를 별도 타 메세지 수신용으로 사용가능한지 여부 (수집기로 포트 연결을 해서 사용가능)

syslog 포트 임의 사용가능 - 수집기로 연결해서 사용할 수 있음 


28. 수집기 스레드 생성시 해당 로테이션 파일에 대한 inode 참조번호를 할당받게 되어, 해당 로테이션 파일명이 리네임 되더라도 해당 파일에 대하 수집은 유효
커넥션을 다시 맺을 신규 파일에 대한 inode 번호가 갱신되어 그 파일에 대해 수집
만약 커넥션을 다시 맺기전, 기존 참조하고 있던 inode번호에 대한 파일에 대한 수집이 모두 이루어지는지? 유실 없는지? 


================================================================================================================
5/25일 추가 질문 사항

29. 단위 수집 작업 종료 후, lastpos 값이 기록된 상태에서, 수집 대상 파일이 리네임될 경우, 수집기 단위 작업이 다시 시작될 경우, 기존 lastpos으로
액세스 하는 경우에 os 레벨/logpresso 레벨에서의 처리는?
 답변 → 해당 경우는 fisrtline이 기존과 달라지므로, lastpos값이 기록되어 있지만, firstline이 달라지는 경우의 수집방법을 따릅니다.(파일의 첫줄부터 수집)
       따라서, 파일이 달라진 상태에서 해당 lastpos에 데이터가 없는 경우에 데이터를 엑세스 하는 경우는 걸러집니다.

30. 하나의 수집기에 대해 다수의 스레드가 생길 경우 수집된 내용에 대해 테이블에 중복 기재가 가능?(기존 상황에서의 답변)
 답변 → 현재는, 하나의 수집기에 대해 하나의 스레드만을 유지합니다.
 ?만약 다수의 스레드가 생겨나 작업이 일어날 경우에 대한 방어책은 무엇?

31. 인덱스 삭제 작업의 절차(메모리 할당/해제 관점)(기존에 삭제가 되지 않았던 이유와 그에 대해 개선 반영 내용)(시스템 로드 관점 설명)

32. thread.startTimestamp가 최초 설정시 logger.startTimestamp와 미미하게 다를 경우는 없는가?

33. 과거치 데이터에 대한 인덱스 빌드 작업시 하루치 작업에 대한 분할 단위 개수는?

34. ftp 접속 개수 확인 

 

  
