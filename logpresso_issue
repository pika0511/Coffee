1. 인덱스 생성/삭제 작업의 세부절차 및 해당 작업에 따른 메모리 할당/해제
 - 인덱스 생성 작업은 수집기로부터 들어오는 데이터에 대한 실시간 인덱스 빌드작업과, 사용자가 지정한 과거기간에 대한 인덱스 빌드작업으로 나뉜다.
 - 과거기간을 지정하지 않을 경우 : 실시간으로 들어오는 데이터에 대한 빌드 작업을 막고, 당일치 과거 데이터에 대한 인덱스 빌드 작업을 선 진행, 인덱스 생성 시점 기준 당일치 과거 데이터에 대한 인덱스 빌드 작업 완료 후, 실시간 입력 데이터에 대한 인덱스 빌드 작업 진행
 - 과거기간 지정시 : 인덱스 생성 시점 기준 당일치 과거 데이터에 대한 인덱스 작업을 완료 후, 실시간 입력되는 데이터에 대한 인덱스 빌드 작업 진행
                인덱스 생성 시점 기준 당일치 과거 데이터에 대한 인덱스 빌드작업을 마친 후, 과거 데이터에 대해 단일 스레드가 백그라운드에서 1일치 양만큼씩 인덱스 빌드 작업을 시작
 - 과거 데이터에 대한 인덱스 빌드 작업단위는 1일, 또한 1일치 데이터를 여러 블럭으로 나눠서 진행
 - 메모리 할당/해제
   기존 : 1일치 인덱스 빌드 작업 완료 시점에, 1일치 데이터에 대한 메모리 해제
   개선 : 1일치 데이터의 단위블럭별 작업 완료 시점에, 단위블럭에 대한 메모리 해제
 - 현재 물류시스템 그룹 수집 로그량 기준(ts01~ts15 → ts_data 테이블)으로 1일치 인덱스 빌드 작업 소요시간 3~4시간
 - 1일치 인덱스 빌드작업이 완료되기 전까지 메모리 해제가 일어나지 않아 old영역 메모리가 지속 상승
   1일치 데이터에 대해 단위블럭별로 순차적으로 메모리를 할당하고, 해제는 1일치 데이터에 대한 인덱스 빌드 작업 완료 시점
   따라서 old영역 메모리 지속상승이 설명이 됨
   이러한 여건에서 인덱스 빌드 작업을 다수 진행 할 경우, 메모리 해제 시점이전에 OOM 발생 가능성 농후(사고 당시에는 2개의 인덱스 빌드작업이 진행중)
   사고 당시에 만약 인덱스 빌드작업이 1개만이었다면, 3~4시간동안 old영역메모리 사용량은 증가했겠지만, OOM 수준은 넘지 않았을 것이며 작업완료 후 메모리를 회복 하였을 것.

2. 절체 동작 세부 사항
 - 액티브노드와 스탠바이는 1초에 한번씩 상대방 노드의 8888포트 오픈여부 지속 확인
 - 8888포트 오픈 확인 실패시 바로 절체가 일어나지 않고, node failure threshold 시간만큼 지속 확인(1분) (gc가 심하게 일어날 경우, 해당 포트의 응답이 늦어지는 경우가 있어 이에 threshold를 1분으로 설정)
 - node failure threshold 시간동안 상대방 노드의 8888포트 오픈여부가 미확인시에 상대방 노드가 다운된 것으로 판단하여 절체 동작 시행
 - 절체 동작시 주요 변경 사항
   ㄱ. 수집기쌍(액티브노드/스탠바이노드)의 stop변수의(true ↔ false) 상호 반전, 재시작하는 수집기의 logger.startTimestamp이 현시점으로 업데이트 됨
       *동일 수집기내에 2개 이상의 스레드가 생성되는 경우 stop변수를 공유하게 됨
   ㄴ. 테이블쌍(액티브노드/스탠바이노드)의 테이블락 상호 반전 
       백업로거는 기본적으로 수집동작을 하지 않지만, 만약 동작을 하게되더라도 테이블락이 걸려 있어 테이블에 데이터를 적재할 수 없음. 

3. 기존 절체 동작시 수집기의 오류 동작
 - 절체가 빠르게 반복될 때, 수집기 스레드에 대한 stop신호 유실이 발생
 - 기본적으로 수집기 스레드는 stop신호를 받아 while문 탈출이후 스레드 종료가 정상동작임
 - 기본적으로 하나의 수집기에 대해 하나의 스레드를 전제
 - 절체가 빠르게 반복되는 경우 stop(true ↔ false)반전 처리 작업이 지연 
 - stop(true ↔ false)신호의 빠른 반전이 일어날 경우, 기존 스레드 소멸작업을 건너뛰고 신규 스레드 생성만 일어나는 경우 발생하여, 해당 스레드가 동작하는 상태에서(언젠가는 stop(true)신호에 의해 종료되었겠지만), 절체에 의한 해당 수집기에 대한 스레드 신규 생성 상황 발생
   → 동일 노드내에 동일 수집기에 대한 2개 이상의 스레드가 존재하는 경우가 발생
   → 해당 스레드가 ssh connection을 요청하는 jsch객체는 기본적으로 스레드 세이프하게 설계되어 있지 않아 다수의 스레드가 동기화 없이 jsch객체에 접근하면 커넥션 누수 발생
 - jsch객체의 커넥션 누수 : 기존 커넥션에 대한 클로즈 처리 없이 신규 커넥션을 호출하는 경우가 발생하여 sshd thread 급증의 원인이 됨  
   
   기존 : 
   while(!stop){ 세부 동작 소스 - while문내에 구문을 모두 시행하기전에 stop변수가 반전이 2번 이상 일어나는 경우, while문내에 구문 시행 후 while문 시행 조건 재검사시 미반영됨 }

   개선 : while문 탈출조건을 추가하여 stop신호가 빠르게 재반전되어 기존 값으로 복구되더라도 , logger.startTimestamp값은 절체 상황속에서 업데이트 되어 해당 스레드의 종료처리를 놓치지 않고 처리할수 있게 됨  
   while(!stop && thread.startTimestamp == logger.startTimestamp) { 세부 동작 소스 - stop변수와는 달리 startTimestamp의 경우 단 한번 바뀌더라도 while문 탈출조건에 해당 }
 
 - thread.startTimestamp : 해당 수집기 스레드가 생성되는 시점
   logger.startTimestamp : 수집기에 시작되는 시점(사용자에 의해서도, 절체에 의해서든)
 - 수집 대상서버의 sshd thread의 급증
   ㄱ. ssh 접속 하나당 서버 sshd thread가 2배 수준이 생성된다. (사고 당시 리소스 모니터링 그래프에서, 로그프레소 스레드 : 3000여 수준, 서버 sshd thread : 7000여 수준)
   ㄴ. 3000여 수준으로 스레드가 증가하게 된 상황 분석
      당시, 초반 10분간 600여개 jsch 커넥션 수가 증가 → 서버 sshd thread는 1200여개 증가
      (10분간 600여개 → 1분 60여개 → 1초당 1개 수준의 jsch 커넥션 증가)
      ※ 1초당 1개 수준의 jsch 커넥션 증가의 의미 : 1초당 1개 수준의 수집기 스레드 증가(스레드 세이프하지 않은 jsch 객체에 동기화 없이 접근하여, 기존 커넥션과 별개로 신규 커넥션 생성)
   ㄷ. 이후 절체가 추가적으로 반복되면서 수집기 스레드가 1~2개 더 증가했고 이에 맞춰 jsch 커넥션 상승 속도 또한 증가 (이에 따라 서버 sshd thread 급증)

4. 수집기 동작 특성
 - FTP 수집 동작 순서
   ㄱ. FTP 서버에 접속
   ㄴ. 대상 파일의 존재 여부와 파일 길이를 확인
   ㄷ. 해당 파일을 다운로드하기 시작하여 첫 라인을 확인한 뒤 다운로드 취소. (전체 파일을 다운로드 받지 않습니다)
   ㄹ. 첫 라인이 마지막으로 확인했을 때와 달라졌을 경우 처음부터 읽을 수 있는 양 만큼 수집.
   ㅁ. 첫 라인이 마지막으로 확인했을 때와 같을 경우 마지막 수집 위치 뒤쪽부터 요청하여 수집.
   ㅂ. FTP 서버 접속 종료
 - 절체가 1초 미만으로 일어나는 경우 수집이 중복으로 일어날 수는 있다. 하지만 스탠바이노드 테이블에 쓰기락이 걸려 있어 백업로거에서 수집된 데이터는 버려진다.
 - 액티브노드 수집기는 항상 수집을 할려고 하고 테이블 락이 없어 테이블에 적재하는 것이 기본동작이며 스탠바이노드 수집기는 stop신호로 정지해있는 것이 기본이지만 start되어 스레드가 생겨날 경우 테이블 락이 걸려 있어 항상 제한적이다.
 - 동일한 수집대상에 대해 수집기 다수의 스레드가 동시에 엑세스해서 읽을려고 할 경우, 수집기 스레드가 동시에 읽을 것으로 기대되는데 이것의 여부는 hp ux의 동작에 달려 있다.
 - 수집시 수집대상 파일에 쓰기작업이 수행중일때도 대기없이 서버OS의 읽기 작업이 수행된다.
 - 로테이션 로그 수집기의 경우
   수집 대상의 파일길이를 확인하여 해당 포지션까지 파일을 읽고 있는 도중, OS의 쓰기작업이 수행되어 파일길이가 변함과 동시에 해당 파일의 교체조건을 충족하여 리네임 될 경우,
   수집기가 기존 수집 단위 작업 종료 후 커넥션을 다시 맺어 해당 파일이름으로 신규 생성된 파일에 액세스하게 되어, OS가 마지막으로 쓰기작업을 한 기존파일에 대한 로그의 일부내용은 유실될 수 있다.
   이러한 경우는 극히 드문 경우이다.
 - 한줄 읽기 검사후 멀티라인을 수집해올때 서버가 주는만큼 가져온다.
 - 폴링 간격이(수집 주기) 1초라고 설정되어 있다면,
   ㄱ. 0.3초 수집작업을 했다면, 0.7초 대기한다. (폴링 간격을 준수)
   ㄴ. 1.3초 수집작업을 했다면, 대기없이 바로 다시 작업을 시작한다. (폴링 간격을 준수)
   ㄷ. 따라서 수집기 스레드는 싱글스레드로 최대 대기시간은 지정된 폴링 간격(수집 주기)이다.
   ㄹ. 수집대상 서버의 부하를 신경쓰지 않고, 로그프레소의 수집속도를 최대화하는 것에 기초에 설계가 되어 있다.

5. DMA에 대한 Cache 설정 비율
 - 테이블, 역인덱스, 블룸필터lv0, 블룸필터lv1을 전체 할당된 DMA 크기의 80~90%을 권장
 - 100%로 할 경우 cep, 인덱스 생성 등의 기타작업에 대해 할당할 DMA가 없어져 OOM 발생 가능

6. columnar type/ row type 테이블 생성 기준
 - 컬럼수가 적으면 row type이 유리
 - columnar type은 인덱스 활용도가 낮다. columnar type에서 만들어진 인덱스에 대해 인덱스를 사용 안할 경우 조회 속도가 더 빠른 경우가 있다.
 - fulltext를 위주로 쓸거면 row type으로 생성 권장
 - 원본을 그대로 저장하는 경우는(ex : ts_raw) 무조건 row type으로 저장   

7. sys_* table들의 적재내용은 GUI상에 기재되어 있지 않은 내부 수집기에 의해 적재 작업이 이루어짐
